№ 6

№ 7
Реализуйте функцию print_given(), которая принимает произвольное количество позиционных и именованных аргументов и выводит все переданные аргументы, указывая тип каждого. Пары аргумент-тип должны выводиться каждая на отдельной строке, в следующем формате:

для позиционных аргументов:
<значение аргумента> <тип аргумента>
для именованных аргументов:
<имя переменной> <значение аргумента> <тип аргумента>
Примечание 1. При выводе позиционные аргументы должны быть расположены в порядке их передачи, именованные — в лексикографическом порядке имен переменных.

Примечание 2. При выводе сначала должны следовать все позиционные аргументы, затем — все именованные.

Примечание 3. Если в функцию ничего не передается, функция ничего не должна выводить.

def print_given(*args, **kwargs):
    for i in args:
        print(i, type(i))

    for key, val in sorted(kwargs.items()):
        print(key, val, type(val))

№ 8
# полностью в нижнем регистре, если букв в нижнем регистре в этой строке больше
#полностью в верхнем регистре, если букв в верхнем регистре в этой строке больше
#полностью в нижнем регистре, если количество букв в верхнем и нижнем регистрах в этой строке совпадает

def convert(s):
    if sum(map(str.islower, s)) >= sum(map(str.isupper, s)):
        return s.lower()
    return s.upper()


№ 9

def filter_anagrams(word, words):
    return list(filter(lambda x: sorted(word) == sorted(x), words))

№ 10

def likes(name):
    n = len(name)
    if n == 0:
        return 'Никто не оценил данную запись'
    elif n == 1:
        return f'{name[0]} оценил(а) данную запись'
    elif n == 2:
        return f'{name[0]} и {name[1]} оценили данную запись'
    elif n == 3:
        return (f'''{name[0]}, {name[1]} и {name[2]} оценили данную запись''')
    elif n > 3:
        return (f'''{name[0]}, {name[1]} и {len(name) - 2} других оценили данную запись''')

№ 11

def index_of_nearest(nums, n):
    if nums:                                           # если в списке nums есть числа:
        minim = min(nums, key=lambda x: abs(x - n))    # мин(ближайщий к числу n) по ключу модуль разности   
        return nums.index(minim)                       # возвращаем наименьший индекс ближайшего числа к n
    return -1                                          # если список nums пуст -- возвращаем -1


№ 12 

def spell(*args: tuple):
    '''
    Принимает произвольное количество позиционных аргументов-слов и возвращает словарь, ключи которого 
    — первые буквы слов, а значения — максимальные длины слов на эту букву.
    '''
    res = dict()
    for word in args:
        key = word[0].lower()
        res[key] = max(res.get(key, 0), len(word))
    return res

№ 13    # Гениальное решения Дмитрия Бойко

def choose_plural(amount: int, declensions: tuple):
    if str(amount).endswith(('0', '5', '6', '7', '8', '9', '11', '12', '13', '14')):
        return f'{amount} {declensions[2]}'
    elif str(amount).endswith('1'):
        return f'{amount} {declensions[0]}'
    else:
        return f'{amount} {declensions[1]}'




№ 14

def get_biggest(numbers):
    if numbers:
        m = max(numbers)
        numbers.sort(reverse=True, key=lambda x: str(x) * m)
        number = int(''.join(map(str, numbers))) 
        return number
    return -1

# находим длину самого длинного числа в списке
# сортируем список, по убыванию, через key=lambda x: str(x) * 1й пункт
# склеиваем все элементы списка
# выводим как число


